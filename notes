/sys/class/

    This is a sysfs interface — a way for the kernel to expose device metadata to user space.
    It holds class objects like "net", "block", or your "task_class".
    Inside, device directories represent real devices and link to their driver & sysfs attributes.
    Purpose: Acts as a standardized place for tools like udev to detect and manage devices.

udev

    A user-space daemon that listens for kernel uevents (like "a new device appeared").
    Reads /sys metadata to decide what /dev/ node to create, its permissions, owner, etc.
    Without it, you’d have to run mknod manually to create /dev/ entries.

/dev/<device>

    This is the special file user programs use with open(), read(), write(), etc.
    When accessed, it routes calls into your driver’s file operations inside the kernel.





        Kernel Space                                User Space
   ──────────────────────────                ──────────────────────────
        [Driver Module]                            [User Apps]
   ──────────────────────────                ──────────────────────────
   
   alloc_chrdev_region()
          │
          ▼
   +---------------------+
   | Major / Minor nums  |   ← Device number allocated
   +---------------------+
          │
   cdev_init() / cdev_add()  <- registers operators to char_dev obj, then add assigns major/minor
          │
          ▼
   class_create()    ← Creates entry in `/sys/class/<class_name>/`
          │
   device_create()
          │
          ▼
   ┌───────────────────────────────────────┐
   │ sysfs entry: /sys/class/<class_name>/  │
   └───────────────────────────────────────┘
          │
          ▼
   (kernel emits "uevent")
          │
          ▼
     ┌────────────┐
     │   udev     │  ← Listens for events from kernel
     └────────────┘
          │
          ▼
   udev rule: Creates /dev/<device_name>
          │
          ▼
   ┌───────────────────────────────────────┐
   │  /dev/<device_name>                    │  ← Character device node
   └───────────────────────────────────────┘
          │
          ▼
   open() / read() / write() / ioctl() calls
          │
          ▼
   Driver's file_operations struct → Your code




## Adding file read and write operation
allocating fix buffer on dirver for read and write data


READ: 
User: read( fd, buf, N ) 
       ↓
VFS calls your read(file, ..., *offset)
       ↓
[Driver] copy data from dev + *offset
       ↓
*offset += bytes_read    <-- YOU must update
       ↓
Return bytes_read (until 0 for EOF)

WRITE:
User: write( fd, buf, N )
       ↓
VFS calls your write(file, ..., *offset)
       ↓
[Driver] copy data into dev + *offset
       ↓
*offset += bytes_written <-- YOU must update
       ↓
Return bytes_written
'

         User Space FD Table               Kernel Open File Table
Process ────────────────────────────┐
                                     │
  fd=3 ───────────────┐              │
                      ▼              │
                 struct file ───────────> inode (data)
                      f_pos = 100
                      read()/write() → updates same f_pos

## so read and write shares same offset, need lseek to read too.

